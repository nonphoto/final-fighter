#final-fighter

##Fighting game framework for Computational Graphics final project.

The goal of this project was to make a fast-paced, top-down fighting game, inspired by Super Smash Bros. and Street Fighter II, as well as other combat-focused games like Dark Souls and Samurai Gunn.  In particular, we wanted to create a game that isn't mechanically difficult to play but still yields interesting emergent gameplay.  From a development perspective, we were interested in creating a system for rapidly iterating on creation of new movesets and the tweaking/balancing of existing moves.

The controls for the game were designed to be simple.  In total, there are only 6 buttons per player: 4 directional inputs and 2 modifier buttons.  Each of these inputs does something individually and the modifier buttons can be combined with any of the directions, producing 14 distinct input combinations, which we feel is a manageable number for both player and character designer, especially when accounting for move symmetry.

As mentioned earlier, one of the goals for this project was to creating a framework for rapid move creation and iteration.  Our solution for this was to create a kind of domain specific language that allows us to define moves using a couple of basic building blocks.  The Player table (tables are the primary way of organizing data and code in Lua, akin to classes in OOP) exposes several methods and varibles that are used to define moves.  To create a new move, a developer just needs to define a method that takes two parameters- the player table and the frame count since the beginning of the move.  Then by calling the provided player methods based on the current frame count, the behavior of the move can be described.  The available methods are: face, move, and attack, each of which is parameterized by direction, strength, etc.  It is even possible to build composite moves by chaining smaller ones together, which can then be bound to a key combination.

Another innovation of ours was to put into code what we coined "move queueing."  In many fighter games, there is a significant barrier of entry in that there is so much extraneous and even boring information that becomes crucial to mastering gameplay.  One example of this is knowing exactly how long a move lasts, so that the player can know exactly when to issue the next move command.  However, this can result in mistakes, wherein a move is issued too soon and therefore fails to go off, or precious seconds can be wasted if the move is issued too late.  Move queueing allows the player to issue his/her next move while the current move is still executing, eliminating these issues, as well as allowing for interesting move combinations, such as a dash followed by an attack in the reverse direction.

Because of the ease with which we can define and change movesets, it was fairly straightfoward to create a game that was both natural to play and balanced.  Ultimately, we decided to give the characters each a fast, short-ranged attack that was less powerful, a longer-ranged and more powerful attack bound by a slight start-up delay, and a quick dash move that allows players to maneuver quickly around their opponent.  The end result is that the game feels smooth and action-filled, but not overwhelming to learn.